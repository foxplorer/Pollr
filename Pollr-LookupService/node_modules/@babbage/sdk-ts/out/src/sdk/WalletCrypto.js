"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletCrypto = void 0;
const sdk_1 = require("@bsv/sdk");
const WERR_errors_1 = require("./WERR_errors");
const privilegedError = new WERR_errors_1.WERR_INVALID_PARAMETER('args.privileged', 'false or undefined. Wallet is a single-keyring wallet, operating without context about whether its configured keyring is privileged.');
/**
 * WalletCrypto implements single-keyring wallet cryptography functions,
 * operating without context about whether its configured keyring is privileged.
 */
class WalletCrypto {
    constructor(keyDeriver) {
        this.keyDeriver = keyDeriver;
    }
    /**
     * Convenience method to obtain the identityKey.
     * @param originator
     * @returns `await this.getPublicKey({ identityKey: true }, originator)`
     */
    async getIdentityKey(originator) {
        return await this.getPublicKey({ identityKey: true }, originator);
    }
    async getPublicKey(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        if (args.identityKey) {
            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };
        }
        else {
            if (!args.protocolID || !args.keyID) {
                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');
            }
            return {
                publicKey: this.keyDeriver
                    .derivePublicKey(args.protocolID, args.keyID, args.counterparty || 'self', args.forSelf)
                    .toString()
            };
        }
    }
    async revealCounterpartyKeyLinkage(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        const { publicKey: identityKey } = await this.getPublicKey({ identityKey: true });
        const linkage = this.keyDeriver.revealCounterpartySecret(args.counterparty);
        const linkageProof = new sdk_1.Schnorr().generateProof(this.keyDeriver.rootKey, this.keyDeriver.rootKey.toPublicKey(), sdk_1.PublicKey.fromString(args.counterparty), sdk_1.Point.fromDER(linkage));
        const linkageProofBin = [
            ...linkageProof.R.encode(true),
            ...linkageProof.SPrime.encode(true),
            ...linkageProof.z.toArray()
        ];
        const revelationTime = new Date().toISOString();
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: linkageProofBin,
            protocolID: [2, 'counterparty linkage revelation'],
            keyID: revelationTime,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            revelationTime,
            encryptedLinkage,
            encryptedLinkageProof
        };
    }
    async revealSpecificKeyLinkage(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        const { publicKey: identityKey } = await this.getPublicKey({ identityKey: true });
        const linkage = this.keyDeriver.revealSpecificSecret(args.counterparty, args.protocolID, args.keyID);
        const { ciphertext: encryptedLinkage } = await this.encrypt({
            plaintext: linkage,
            protocolID: [2, `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        const { ciphertext: encryptedLinkageProof } = await this.encrypt({
            plaintext: [0], // Proof type 0, no proof provided
            protocolID: [2, `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`],
            keyID: args.keyID,
            counterparty: args.verifier
        });
        return {
            prover: identityKey,
            verifier: args.verifier,
            counterparty: args.counterparty,
            protocolID: args.protocolID,
            keyID: args.keyID,
            encryptedLinkage,
            encryptedLinkageProof,
            proofType: 0
        };
    }
    async encrypt(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { ciphertext: key.encrypt(args.plaintext) };
    }
    async decrypt(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { plaintext: key.decrypt(args.ciphertext) };
    }
    async createHmac(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        return { hmac: sdk_1.Hash.sha256hmac(key.toArray(), args.data) };
    }
    async verifyHmac(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty || 'self');
        const valid = sdk_1.Hash.sha256hmac(key.toArray(), args.data).toString() === args.hmac.toString();
        if (!valid) {
            const e = new Error('HMAC is not valid');
            e.code = 'ERR_INVALID_HMAC';
            throw e;
        }
        return { valid };
    }
    async createSignature(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        if (!args.hashToDirectlySign && !args.data) {
            throw new Error('args.data or args.hashToDirectlySign must be valid');
        }
        const hash = args.hashToDirectlySign || sdk_1.Hash.sha256(args.data);
        const key = this.keyDeriver.derivePrivateKey(args.protocolID, args.keyID, args.counterparty || 'anyone');
        return { signature: sdk_1.ECDSA.sign(new sdk_1.BigNumber(hash), key, true).toDER() };
    }
    async verifySignature(args, originator) {
        if (args.privileged) {
            throw privilegedError;
        }
        if (!args.hashToDirectlyVerify && !args.data) {
            throw new Error('args.data or args.hashToDirectlyVerify must be valid');
        }
        const hash = args.hashToDirectlyVerify || sdk_1.Hash.sha256(args.data);
        const key = this.keyDeriver.derivePublicKey(args.protocolID, args.keyID, args.counterparty || 'self', args.forSelf);
        const valid = sdk_1.ECDSA.verify(new sdk_1.BigNumber(hash), sdk_1.Signature.fromDER(args.signature), key);
        if (!valid) {
            const e = new Error('Signature is not valid');
            e.code = 'ERR_INVALID_SIGNATURE';
            throw e;
        }
        return { valid };
    }
}
exports.WalletCrypto = WalletCrypto;
//# sourceMappingURL=WalletCrypto.js.map