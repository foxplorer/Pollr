"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asBuffer = asBuffer;
exports.asString = asString;
exports.asArray = asArray;
exports.sha256Hash = sha256Hash;
exports.doubleSha256HashLE = doubleSha256HashLE;
exports.doubleSha256BE = doubleSha256BE;
exports.verifyTruthy = verifyTruthy;
exports.asBsvSdkScript = asBsvSdkScript;
exports.asBsvSdkTx = asBsvSdkTx;
const sdk_1 = require("@bsv/sdk");
function asBuffer(val, encoding) {
    let b;
    if (Buffer.isBuffer(val))
        b = val;
    else if (typeof val === 'string')
        b = Buffer.from(val, encoding !== null && encoding !== void 0 ? encoding : 'hex');
    else
        b = Buffer.from(val);
    return b;
}
/**
 * @param val Value to convert to encoded string if not already a string.
 * @param encoding
 */
function asString(val, encoding) {
    return Buffer.isBuffer(val) ? val.toString(encoding !== null && encoding !== void 0 ? encoding : 'hex') : val;
}
function asArray(val, encoding) {
    let a;
    if (Array.isArray(val))
        a = val;
    else if (Buffer.isBuffer(val))
        a = Array.from(val);
    else
        a = Array.from(Buffer.from(val, encoding || 'hex'));
    return a;
}
/**
 * Calculate the SHA256 hash of a Buffer.
 * @returns sha256 hash of buffer contents.
 * @publicbody
 */
function sha256Hash(buffer) {
    const msg = asArray(buffer);
    const first = new sdk_1.Hash.SHA256().update(msg).digest();
    return asBuffer(first);
}
/**
 * Calculate the SHA256 hash of the SHA256 hash of a Buffer.
 * @param data is Buffer or hex encoded string
 * @returns double sha256 hash of buffer contents, byte 0 of hash first.
 * @publicbody
 */
function doubleSha256HashLE(data, encoding) {
    const msg = asArray(data, encoding);
    const first = new sdk_1.Hash.SHA256().update(msg).digest();
    const second = new sdk_1.Hash.SHA256().update(first).digest();
    return asBuffer(second);
}
/**
 * Calculate the SHA256 hash of the SHA256 hash of a Buffer.
 * @param data is Buffer or hex encoded string
 * @returns reversed (big-endian) double sha256 hash of data, byte 31 of hash first.
 * @publicbody
 */
function doubleSha256BE(data, encoding) {
    return doubleSha256HashLE(data, encoding).reverse();
}
function verifyTruthy(v, description) {
    if (v == null)
        throw new Error(description !== null && description !== void 0 ? description : 'A truthy value is required.');
    return v;
}
function asBsvSdkScript(script) {
    if (Buffer.isBuffer(script)) {
        script = sdk_1.Script.fromHex(asString(script));
    }
    else if (typeof script === 'string') {
        script = sdk_1.Script.fromHex(script);
    }
    return script;
}
function asBsvSdkTx(tx) {
    if (Buffer.isBuffer(tx)) {
        tx = sdk_1.Transaction.fromHex(asString(tx));
    }
    else if (typeof tx === 'string') {
        tx = sdk_1.Transaction.fromHex(tx);
    }
    return tx;
}
//# sourceMappingURL=Helpers.js.map