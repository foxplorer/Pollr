"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWalletOutpoint = parseWalletOutpoint;
exports.validateSatoshis = validateSatoshis;
exports.validateOptionalInteger = validateOptionalInteger;
exports.validateInteger = validateInteger;
exports.validatePositiveIntegerOrZero = validatePositiveIntegerOrZero;
exports.validateStringLength = validateStringLength;
exports.validateCreateActionInput = validateCreateActionInput;
exports.validateCreateActionOutput = validateCreateActionOutput;
exports.validateCreateActionOptions = validateCreateActionOptions;
exports.validateCreateActionArgs = validateCreateActionArgs;
exports.validateSignActionOptions = validateSignActionOptions;
exports.validateSignActionArgs = validateSignActionArgs;
exports.validateAbortActionArgs = validateAbortActionArgs;
exports.validateWalletPayment = validateWalletPayment;
exports.validateBasketInsertion = validateBasketInsertion;
exports.validateInternalizeOutput = validateInternalizeOutput;
exports.validateOriginator = validateOriginator;
exports.validateInternalizeActionArgs = validateInternalizeActionArgs;
exports.validateOptionalOutpointString = validateOptionalOutpointString;
exports.validateOutpointString = validateOutpointString;
exports.validateRelinquishOutputArgs = validateRelinquishOutputArgs;
exports.validateListCertificatesArgs = validateListCertificatesArgs;
exports.validateAcquireCertificateArgs = validateAcquireCertificateArgs;
exports.validateListOutputsArgs = validateListOutputsArgs;
exports.validateListActionsArgs = validateListActionsArgs;
const sdk_1 = require("@bsv/sdk");
const __1 = require("..");
function parseWalletOutpoint(outpoint) {
    const [txid, vout] = outpoint.split('.');
    return { txid, vout: Number(vout) };
}
function defaultTrue(v) { return v === undefined ? true : v; }
function defaultFalse(v) { return v === undefined ? false : v; }
function defaultZero(v) { return v === undefined ? 0 : v; }
function default0xffffffff(v) { return v === undefined ? 0xffffffff : v; }
function defaultOne(v) { return v === undefined ? 1 : v; }
function defaultEmpty(v) { return v === undefined ? [] : v; }
function validateOptionalStringLength(s, name, min, max) {
    if (s === undefined)
        return undefined;
    return validateOptionalStringLength(s, name, min, max);
}
function validateSatoshis(v, name, min) {
    if (v === undefined || !Number.isInteger(v) || v < 0 || v > 21e14)
        throw new __1.WERR_INVALID_PARAMETER(name, 'a valid number of satoshis');
    if (min !== undefined && v < min)
        throw new __1.WERR_INVALID_PARAMETER(name, `at least ${min} satoshis.`);
    return v;
}
function validateOptionalInteger(v, name, min, max) {
    if (v === undefined)
        return undefined;
    return validateInteger(v, name, undefined, min, max);
}
function validateInteger(v, name, defaultValue, min, max) {
    if (v === undefined) {
        if (defaultValue !== undefined)
            return defaultValue;
        throw new __1.WERR_INVALID_PARAMETER(name, 'a valid integer');
    }
    if (!Number.isInteger(v))
        throw new __1.WERR_INVALID_PARAMETER(name, 'an integer');
    v = Number(v);
    if (min !== undefined && v < min)
        throw new __1.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && v > max)
        throw new __1.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return v;
}
function validatePositiveIntegerOrZero(v, name) {
    return validateInteger(v, name, 0, 0);
}
function validateStringLength(s, name, min, max) {
    const bytes = sdk_1.Utils.toArray(s, 'utf8').length;
    if (min !== undefined && bytes < min)
        throw new __1.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && bytes > max)
        throw new __1.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function validateOptionalBasket(s) {
    if (s === undefined)
        return undefined;
    return validateBasket(s);
}
function validateBasket(s) {
    return validateIdentifier(s, 'basket', 1, 300);
}
function validateLabel(s) {
    return validateIdentifier(s, 'label', 1, 300);
}
function validateTag(s) {
    return validateIdentifier(s, 'tag', 1, 300);
}
function validateIdentifier(s, name, min, max) {
    s = s.trim().toLowerCase();
    const bytes = sdk_1.Utils.toArray(s, 'utf8').length;
    if (min !== undefined && bytes < min)
        throw new __1.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && bytes > max)
        throw new __1.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function validateOptionalBase64String(s, name, min, max) {
    if (s === undefined)
        return undefined;
    return validateBase64String(s, name, min, max);
}
function validateBase64String(s, name, min, max) {
    var _a;
    // Remove any whitespace and check if the string length is valid for Base64
    s = s.trim();
    const base64Regex = /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/;
    const paddingCount = ((_a = (s.match(/=+$/) || [])[0]) === null || _a === void 0 ? void 0 : _a.length) || 0;
    if (paddingCount > 2 || (s.length % 4 !== 0 && paddingCount !== 0) || !base64Regex.test(s)) {
        throw new __1.WERR_INVALID_PARAMETER(name, `balid base64 string`);
    }
    const bytes = sdk_1.Utils.toArray(s, 'base64').length;
    if (min !== undefined && bytes < min)
        throw new __1.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && bytes > max)
        throw new __1.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function validateOptionalHexString(s, name, min, max) {
    if (s === undefined)
        return undefined;
    return validateHexString(s, name, min, max);
}
/**
 * @param s
 * @param name
 * @param min if valid, string length minimum (not bytes)
 * @param max if valid, string length maximum (not bytes)
 * @returns
 */
function validateHexString(s, name, min, max) {
    s = s.trim().toUpperCase();
    if (s.length % 2 === 1)
        throw new __1.WERR_INVALID_PARAMETER(name, `even length, not ${s.length}.`);
    const hexRegex = /^[0-9A-Fa-f]+$/;
    if (!hexRegex.test(s))
        throw new __1.WERR_INVALID_PARAMETER(name, `hexadecimal string.`);
    if (min !== undefined && s.length < min)
        throw new __1.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);
    if (max !== undefined && s.length > max)
        throw new __1.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);
    return s;
}
function validateCreateActionInput(i) {
    if (i.unlockingScript === undefined && i.unlockingScriptLength === undefined)
        throw new __1.WERR_INVALID_PARAMETER('unlockingScript, unlockingScriptLength', `at least one valid value.`);
    const unlockingScript = validateOptionalHexString(i.unlockingScript, 'unlockingScript');
    const unlockingScriptLength = i.unlockingScriptLength || unlockingScript.length / 2;
    if (unlockingScript && unlockingScriptLength !== unlockingScript.length / 2)
        throw new __1.WERR_INVALID_PARAMETER('unlockingScriptLength', `length unlockingScript if both valid.`);
    const vi = {
        outpoint: parseWalletOutpoint(i.outpoint),
        inputDescription: validateStringLength(i.inputDescription, 'inputDescription', 5, 50),
        unlockingScript,
        unlockingScriptLength,
        sequenceNumber: default0xffffffff(i.sequenceNumber)
    };
    return vi;
}
function validateCreateActionOutput(o) {
    const vo = {
        lockingScript: validateHexString(o.lockingScript, 'lockingScript'),
        satoshis: validateSatoshis(o.satoshis, 'satoshis'),
        outputDescription: validateStringLength(o.outputDescription, 'outputDescription', 5, 50),
        basket: validateOptionalBasket(o.basket),
        customInstructions: o.customInstructions,
        tags: defaultEmpty(o.tags).map(t => validateTag(t))
    };
    return vo;
}
/**
 * Set all default true/false booleans to true or false if undefined.
 * Set all possibly undefined numbers to their default values.
 * Set all possibly undefined arrays to empty arrays.
 * Convert string outpoints to `{ txid: string, vout: number }`
 */
function validateCreateActionOptions(options) {
    const o = options || {};
    const vo = {
        signAndProcess: defaultTrue(o.signAndProcess),
        acceptDelayedBroadcast: defaultTrue(o.acceptDelayedBroadcast),
        knownTxids: defaultEmpty(o.knownTxids),
        returnTXIDOnly: defaultFalse(o.returnTXIDOnly),
        noSend: defaultFalse(o.noSend),
        noSendChange: defaultEmpty(o.noSendChange).map(nsc => parseWalletOutpoint(nsc)),
        sendWith: defaultEmpty(o.sendWith),
        randomizeOutputs: defaultTrue(o.randomizeOutputs)
    };
    return vo;
}
function validateCreateActionArgs(args) {
    var _a;
    const vargs = {
        description: validateStringLength(args.description, 'description', 5, 50),
        inputBEEF: args.inputBEEF,
        inputs: defaultEmpty(args.inputs).map(i => validateCreateActionInput(i)),
        outputs: defaultEmpty(args.outputs).map(o => validateCreateActionOutput(o)),
        lockTime: defaultZero(args.lockTime),
        version: defaultOne(args.version),
        labels: defaultEmpty((_a = args.labels) === null || _a === void 0 ? void 0 : _a.map(l => validateLabel(l))),
        options: validateCreateActionOptions(args.options),
        isSendWith: false,
        isDelayed: false,
        isNoSend: false,
        isNewTx: false,
        isSignAction: false,
    };
    vargs.isSendWith = vargs.options.sendWith.length > 0;
    vargs.isNewTx = (vargs.inputs.length > 0) || (vargs.outputs.length > 0);
    vargs.isSignAction = vargs.isNewTx && (vargs.options.signAndProcess === false || vargs.inputs.some(i => i.unlockingScript === undefined));
    vargs.isDelayed = vargs.options.acceptDelayedBroadcast;
    vargs.isNoSend = vargs.options.noSend;
    if (!vargs.isSendWith && !vargs.isNewTx)
        throw new __1.WERR_INVALID_PARAMETER('args', 'either at least one input or output, or a sendWith.');
    return vargs;
}
/**
 * Set all default true/false booleans to true or false if undefined.
 * Set all possibly undefined numbers to their default values.
 * Set all possibly undefined arrays to empty arrays.
 * Convert string outpoints to `{ txid: string, vout: number }`
 */
function validateSignActionOptions(options) {
    const o = options || {};
    const vo = {
        acceptDelayedBroadcast: defaultTrue(o.acceptDelayedBroadcast),
        returnTXIDOnly: defaultFalse(o.returnTXIDOnly),
        noSend: defaultFalse(o.noSend),
        sendWith: defaultEmpty(o.sendWith)
    };
    return vo;
}
function validateSignActionArgs(args) {
    const vargs = {
        spends: args.spends,
        reference: args.reference,
        options: validateSignActionOptions(args.options),
        isSendWith: false,
        isDelayed: false,
        isNoSend: false,
        isNewTx: true
    };
    vargs.isSendWith = vargs.options.sendWith.length > 0;
    vargs.isDelayed = vargs.options.acceptDelayedBroadcast;
    vargs.isNoSend = vargs.options.noSend;
    return vargs;
}
function validateAbortActionArgs(args) {
    const vargs = {
        reference: validateBase64String(args.reference, 'reference'),
        log: ''
    };
    return vargs;
}
function validateWalletPayment(args) {
    if (args === undefined)
        return undefined;
    const v = {
        derivationPrefix: validateBase64String(args.derivationPrefix, 'derivationPrefix'),
        derivationSuffix: validateBase64String(args.derivationSuffix, 'derivationSuffix'),
        senderIdentityKey: validateHexString(args.senderIdentityKey, 'senderIdentityKey')
    };
    return v;
}
function validateBasketInsertion(args) {
    if (args === undefined)
        return undefined;
    const v = {
        basket: validateBasket(args.basket),
        customInstructions: validateOptionalStringLength(args.customInstructions, 'customInstructions', 0, 1000), // TODO: real max??
        tags: defaultEmpty(args.tags).map(t => validateTag(t))
    };
    return v;
}
function validateInternalizeOutput(args) {
    if (args.protocol !== 'basket insertion' && args.protocol !== 'wallet payment')
        throw new __1.WERR_INVALID_PARAMETER('protocol', `'basket insertion' or 'wallet payment'`);
    const v = {
        outputIndex: validatePositiveIntegerOrZero(args.outputIndex, 'outputIndex'),
        protocol: args.protocol,
        paymentRemittance: validateWalletPayment(args.paymentRemittance),
        insertionRemittance: validateBasketInsertion(args.insertionRemittance)
    };
    return v;
}
function validateOriginator(s) {
    if (s === undefined)
        return undefined;
    s = s.trim().toLowerCase();
    validateStringLength(s, 'originator', 1, 250);
    const sps = s.split('.');
    for (const sp of sps) {
        validateStringLength(sp, 'originator part', 1, 63);
    }
}
function validateInternalizeActionArgs(args) {
    const vargs = {
        tx: args.tx,
        outputs: args.outputs.map(o => validateInternalizeOutput(o)),
        description: validateStringLength(args.description, 'description', 5, 50),
        labels: (args.labels || []).map(t => validateLabel(t)),
        seekPermission: defaultTrue(args.seekPermission),
        log: ''
    };
    return vargs;
}
function validateOptionalOutpointString(outpoint, name) {
    if (outpoint === undefined)
        return undefined;
    return validateOutpointString(outpoint, name);
}
function validateOutpointString(outpoint, name) {
    const s = outpoint.split('.');
    if (s.length !== 2 || !Number.isInteger(Number(s[1])))
        throw new __1.WERR_INVALID_PARAMETER(name, `txid as hex string and numeric output index joined with '.'`);
    const txid = validateHexString(s[0], `${name} txid`, undefined, 64);
    const vout = validatePositiveIntegerOrZero(Number(s[1]), `${name} vout`);
    return `${txid}.${vout}`;
}
function validateRelinquishOutputArgs(args) {
    const vargs = {
        basket: validateBasket(args.basket),
        output: validateOutpointString(args.output, 'output'),
        log: ''
    };
    return vargs;
}
function validateListCertificatesArgs(args) {
    const vargs = {
        certifiers: defaultEmpty(args.certifiers.map(c => validateHexString(c, 'certifiers'))),
        types: defaultEmpty(args.types.map(t => validateBase64String(t, 'types'))),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validatePositiveIntegerOrZero(defaultZero(args.offset), 'offset'),
        privileged: defaultFalse(args.privileged),
        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),
        log: ''
    };
    return vargs;
}
function validateCertificateFields(fields) {
    for (const fieldName of Object.keys(fields)) {
        validateStringLength(fieldName, 'field name');
    }
    return fields;
}
function validateOptionalKeyringRevealer(kr, name) {
    if (kr === undefined)
        return undefined;
    if (kr === 'certifier')
        return kr;
    return validateHexString(kr, name);
}
function validateOptionalKeyringForSubject(kr, name) {
    if (kr === undefined)
        return undefined;
    for (const fn of Object.keys(kr)) {
        validateStringLength(fn, `${name} field name`, 1, 50);
        validateBase64String(kr[fn], `${name} field value`);
    }
    return kr;
}
function validateAcquireCertificateArgs(args) {
    const vargs = {
        type: validateBase64String(args.type, 'type'),
        certifier: validateHexString(args.certifier, 'certifier'),
        acquisitionProtocol: args.acquisitionProtocol,
        fields: validateCertificateFields(args.fields),
        serialNumber: validateOptionalBase64String(args.serialNumber, 'serialNumber'),
        revocationOutpoint: validateOptionalOutpointString(args.revocationOutpoint, 'revocationOutpoint'),
        signature: validateOptionalHexString(args.signature, 'signature'),
        certifierUrl: args.certifierUrl,
        keyringRevealer: validateOptionalKeyringRevealer(args.keyringRevealer, 'keyringRevealer'),
        keyringForSubject: validateOptionalKeyringForSubject(args.keyringForSubject, 'keyringForSubject'),
        privileged: defaultFalse(args.privileged),
        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),
        log: ''
    };
    if (vargs.privileged && !vargs.privilegedReason)
        throw new __1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);
    return vargs;
}
/**
   * @param {BasketStringUnder300Bytes} args.basket - Required. The associated basket name whose outputs should be listed.
   * @param {OutputTagStringUnder300Bytes[]} [args.tags] - Optional. Filter outputs based on these tags.
   * @param {'all' | 'any'} [args.tagQueryMode] - Optional. Filter mode, defining whether all or any of the tags must match. By default, any tag can match.
   * @param {'locking scripts' | 'entire transactions'} [args.include] - Optional. Whether to include locking scripts (with each output) or entire transactions (as aggregated BEEF, at the top level) in the result. By default, unless specified, neither are returned.
   * @param {BooleanDefaultFalse} [args.includeEntireTransactions] - Optional. Whether to include the entire transaction(s) in the result.
   * @param {BooleanDefaultFalse} [args.includeCustomInstructions] - Optional. Whether custom instructions should be returned in the result.
   * @param {BooleanDefaultFalse} [args.includeTags] - Optional. Whether the tags associated with the output should be returned.
   * @param {BooleanDefaultFalse} [args.includeLabels] - Optional. Whether the labels associated with the transaction containing the output should be returned.
   * @param {PositiveIntegerDefault10Max10000} [args.limit] - Optional limit on the number of outputs to return.
   * @param {PositiveIntegerOrZero} [args.offset] - Optional. Number of outputs to skip before starting to return results.
   * @param {BooleanDefaultTrue} [args.seekPermission] — Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.
 */
function validateListOutputsArgs(args) {
    let tagQueryMode;
    if (args.tagQueryMode === undefined || args.tagQueryMode === 'any')
        tagQueryMode = 'any';
    else if (args.tagQueryMode === 'all')
        tagQueryMode = 'all';
    else
        throw new __1.WERR_INVALID_PARAMETER('tagQueryMode', `undefined, 'any', or 'all'`);
    const vargs = {
        basket: validateStringLength(args.basket, 'basket', 0, 300),
        tags: (args.tags || []).map(t => validateStringLength(t, 'tag', 0, 300)),
        tagQueryMode,
        includeLockingScripts: args.include === 'locking scripts',
        includeTransactions: args.include === 'entire transactions',
        includeCustomInstructions: defaultFalse(args.includeCustomInstructions),
        includeTags: defaultFalse(args.includeTags),
        includeLabels: defaultFalse(args.includeLabels),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validateInteger(args.offset, 'offset', 0, 0, undefined),
        seekPermission: defaultTrue(args.seekPermission),
        knownTxids: [],
    };
    return vargs;
}
/**
   * @param {sdk.LabelStringUnder300Bytes[]} args.labels - An array of labels used to filter actions.
   * @param {'any' | 'all'} [args.labelQueryMode] - Optional. Specifies how to match labels (default is any which matches any of the labels).
   * @param {sdk.BooleanDefaultFalse} [args.includeLabels] - Optional. Whether to include transaction labels in the result set.
   * @param {sdk.BooleanDefaultFalse} [args.includeInputs] - Optional. Whether to include input details in the result set.
   * @param {sdk.BooleanDefaultFalse} [args.includeInputSourceLockingScripts] - Optional. Whether to include input source locking scripts in the result set.
   * @param {sdk.BooleanDefaultFalse} [args.includeInputUnlockingScripts] - Optional. Whether to include input unlocking scripts in the result set.
   * @param {sdk.BooleanDefaultFalse} [args.includeOutputs] - Optional. Whether to include output details in the result set.
   * @param {sdk.BooleanDefaultFalse} [args.includeOutputLockingScripts] - Optional. Whether to include output locking scripts in the result set.
   * @param {sdk.PositiveIntegerDefault10Max10000} [args.limit] - Optional. The maximum number of transactions to retrieve.
   * @param {sdk.PositiveIntegerOrZero} [args.offset] - Optional. Number of transactions to skip before starting to return the results.
   * @param {sdk.BooleanDefaultTrue} [args.seekPermission] — Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.
 */
function validateListActionsArgs(args) {
    let labelQueryMode;
    if (args.labelQueryMode === undefined || args.labelQueryMode === 'any')
        labelQueryMode = 'any';
    else if (args.labelQueryMode === 'all')
        labelQueryMode = 'all';
    else
        throw new __1.WERR_INVALID_PARAMETER('labelQueryMode', `undefined, 'any', or 'all'`);
    const vargs = {
        labels: (args.labels || []).map(t => validateLabel(t)),
        labelQueryMode,
        includeLabels: defaultFalse(args.includeLabels),
        includeInputs: defaultFalse(args.includeInputs),
        includeInputSourceLockingScripts: defaultFalse(args.includeInputSourceLockingScripts),
        includeInputUnlockingScripts: defaultFalse(args.includeInputUnlockingScripts),
        includeOutputs: defaultFalse(args.includeOutputs),
        includeOutputLockingScripts: defaultFalse(args.includeOutputLockingScripts),
        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),
        offset: validateInteger(args.offset, 'offset', 0, 0, undefined),
        seekPermission: defaultTrue(args.seekPermission)
    };
    if (vargs.labels.length < 1)
        throw new __1.WERR_INVALID_PARAMETER('labels', 'at least one label');
    return vargs;
}
//# sourceMappingURL=helpers.js.map